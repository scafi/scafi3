incarnation: scafi3

network-model:
  type: ConnectWithinDistance
  parameters: [ 5 ]

_pool: &program
  - time-distribution: 1
    program:
      name: GradientInlined
      code: |
        package it.unibo.scafi.test
    
        import it.unibo.scafi.alchemist.device.sensors.AlchemistEnvironmentVariables
        import it.unibo.scafi.language.fc.syntax.FieldCalculusSyntax
        import it.unibo.scafi.language.xc.calculus.ExchangeCalculus
        import it.unibo.scafi.libraries.All
        import it.unibo.scafi.libraries.All.given
        import it.unibo.scafi.libraries.FieldCalculusLibrary.share
        import it.unibo.scafi.message.Codables.given
        import it.unibo.scafi.sensors.DistanceSensor
        import it.unibo.scafi.sensors.DistanceSensor.senseDistance
      
        object GradientInlined:
          type Lang = ExchangeCalculus { type DeviceId = Int } & FieldCalculusSyntax & DistanceSensor[Double] &
          AlchemistEnvironmentVariables
        
          def gradientInlined(using Lang): Double =
            share(Double.MaxValue): prevValues =>
              val distances = senseDistance[Double]
              val minDistance = prevValues.alignedMap(distances)(_ + _).withoutSelf.min
              if AlchemistEnvironmentVariables.get[Boolean]("source") then 0.0 else minDistance
      entrypoint: it.unibo.scafi.test.GradientInlined.gradientInlined

deployments:
  - type: Point
    parameters: [ -1, -1 ]
    programs:
      - *program
    contents:
      - molecule: source
        concentration: true
  - type: Grid
    parameters: [ 0, 0, 3, 3, 1, 1 ]
    programs:
      - *program
    contents:
      - molecule: source
        concentration: false